<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yoga Sutra Trees</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/interactjs/dist/interact.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    

    <script src="https://unpkg.com/cytoscape-context-menus/cytoscape-context-menus.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/js/select2.min.js"></script>
    
    <script src="http://cytoscape.github.io/cytoscape.js/api/cytoscape.js-latest/cytoscape.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-node-html-label@1.1.3/dist/cytoscape-node-html-label.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@editorjs/editorjs@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-cloud/1.2.5/d3.layout.cloud.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    
  
    
    
</head>
<style>
    body {
        transition: background-color 1.5s ease;
    }
    #cy {
        width: 1200px;
        height: 700px;
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
    }
    
  .resizable-section {
    overflow-y: auto; /* Enable vertical scrollbar if content overflows */

  }

    #details-content {
            overflow: auto;
            max-height: 400px; /* Set the maximum height */
            width: 100%;
        }    
    .hide {
            display: none !important;
    }    
    @media screen and (max-aspect-ratio: 1/1) {
    body {
        transform: rotate(-90deg);
        transform-origin: left top;
        width: 100vh;
        height: 100vw;
        overflow-x: hidden;
        position: absolute;
        top: 100%;
        left: 0;
    }
    }
    
    @media (max-width: 768px) {
    #wonderHeader {
      height: 6vh; /* Adjust the height for tablets and mobile devices */
    }
   }

    #leftSidebar {
        backdrop-filter: blur(3px);
    }    
    #sidebar {
        backdrop-filter: blur(3px);
    }

    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgb(0,0,0); /* Fallback color */
        background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }

        .modal-content {
        background-color: #fefefe;
        margin: 15% auto; /* 15% from the top and centered */
        padding: 20px;
        border: 1px solid #888;
        width: 60%; /* Could be more or less, depending on screen size */
        display: flex;
    flex-direction: column;
    align-items: stretch;
    }

    #advancedSearchInput,
    #advancedSearchSelector {
        margin-bottom: 10px;
    }

    #advancedSearchSelector {
        height: 100px;
        overflow: auto;
    }

    #context_menu_text {
        overflow: auto;
    }

    .tooltip {
    position: absolute;
    text-align: center;
    width: 60px;
    height: 28px;
    padding: 2px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
    }

    #nodeAttributes {
    max-height: 400px; /* Set this to the maximum height you want */
    overflow-y: auto; /* Make it scrollable */
    word-wrap: break-word; /* Break words to prevent horizontal overflow */
    }

    #context_menu_text {
            font-family: 'Garamond', 'Adobe Garamond', serif;
            line-height: 1.5;
            font-size: 13;
        }

    table {
        border-collapse: collapse;
        width: auto;  /* Change this */
        table-layout: auto;  /* Add this */
    }
    th, td {
        border: 1px solid black;
        padding: 8px;
        text-align: center;
    }
    th {
        background-color: #f1f1f1;
    }   

</style>

<body>

  <div id="cy"></div>

  <div id="sidebar" class="fixed right-0 bottom-0  w-64 overflow-auto p-4 flex flex-col items-center justify-center transition-transform transform duration-500 ease-in-out border-t border-gray-600" style="height: 90%;  transform: translateX(100%); background-color: rgba(250, 250, 248, 0.8); ">
    <h2 class="text-xl font-bold mb-4 text-grey-500">Options</h2>
    <button id="add-link-btn" class="hover:text-indigo-600 active:text-violet-700 text-white w-full font-bold py-1 px-4 rounded mb-2" style="background-color: #248e95;">Add Edge</button>
    <button id="remove-link-btn" class="hover:text-indigo-600 active:text-violet-700 text-white w-full font-bold py-1 px-4 rounded mb-2" style="background-color: #248e95;" >Remove edge</button>
    <div style="display: flex; justify-content: space-between;">
        <input type="color" id="color-picker-nodes" value="#FDF6B2">
        <input type="color" id="color-picker-border" value="#A2E1E4">
        <input type="color" id="color-picker-edges" value="#C6E0EA">
        <input type="color" id="color-picker-highlight" value="#F98645">
    </div>
    <div class="mt-2 w-full">
        <h2 class="text-base text-center text-gray-600">Display Select</h2>
        <select id="displaySelector" class="block w-full py-4 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" multiple="multiple"></select>  
        <h2 class="text-base text-center text-gray-600">Node Select</h2>
        <select id="attributeSelector" class=" block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" multiple="multiple"></select>  
        <select id="tagSelect" class="mt-1 mb-20 block w-full py-2 px-3 border border-gray-300 bg-transparent rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" multiple="multiple"></select>  
    </div>
    <div class="flex justify-between">
        <input type="text" id="node-id-input" placeholder="Search Aphorism" class="mt-5 flex-grow bg-transparent text-center">
    </div>
  </div>


  <div id="searchModal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <input type="text" id="advancedSearchInput" placeholder="Search Text Here">
      <select id="advancedSearchSelector" class=" block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" multiple="multiple"></select>  
      <div id="graphicPlot"></div>
      <div id="searchResults"></div>
      <div id="nodeAttributes"  style="height: 375px;"></div>
      <div id="wordCloud"  style="height: 300px;"></div>
      <div id="editorjs" style="height: 375px;"></div>      
    </div>
  </div>

 <div id="custom-context-menu" class="context_menu" style="display: none; position: absolute; z-index: 1000; background-color: #fff; border: 1px solid #ccc; padding: 10px;">
    <div id="context_menu_text"  style="height: 375px;"></div>
</div>  



    <div id="leftSidebar" class="fixed left-0 bottom-0 w-96 resize-x overflow-auto p-4 flex flex-col items-center justify-center transition-transform transform duration-500 ease-in-out border-t border-gray-600" style="height: 90%; transform: translateX(-100%); background-color: rgba(250, 250, 250, 0.85);">
                <input type="color" id="color-picker-specificnode" value="#FDF6B2" style="position: absolute; top: 10px; right: 10px;">
                
                
            <p id="titleSection" ondblclick="makeTitleEditable(this)" class="w-full" style="text-align: center; font-weight: 500;"></p>    
                        
                
            <div id="details-content" class="w-full p-4 border-b border-gray-700 resizable-section text-justify"></div>

            <div id="editable-content" class="w-full p-2 " style="display: flex; flex-direction: column;">

            <p id="tagsSection" ondblclick="makeTagsEditable(this)" class="w-full border-b border-gray-700 p-4 resizable-section">
                <strong>Click on a node to start.</strong> Once started, those three fields are editable with double click and resizable with dragging. The title of the Sutra can also be edited with double click. Insert the tags as comma separated.
                
            </p>

            <p id="referencesSection" ondblclick="makeReferencesEditable(this)" class="w-full border-b p-4 border-gray-700 resizable-section">
                You can also resize the panel touching the right side. You can change the node color using the color picked in the right corner. You can change the color of the graph (background, border, edge, selected) using the right color pickers.
            </p>

            <p id="commentsSection" ondblclick="makeCommentsEditable(this)" class="w-full p-4 border-b border-gray-700 resizable-section">
                You can use the right panel to select the content shown for a node, both in the display and in the panel.
            </p>
                </div>
    </div>



  <div id="myDiv" style="background-image: url('bg8.jpg'); background-repeat: no-repeat; background-size: cover; background-attachment: fixed; height: 1000px;">
    <div>
        <header id="wonderHeader" class="fixed w-full bg-white bg-opacity-75 top-0" style="height: 10vh;">
            <div id="divideLine" class="absolute inset-x-1/4 bottom-0 h-px bg-gray-700"></div>
            <nav class="flex items-center justify-between p-6 lg:px-8" aria-label="Global">
                <div class="flex lg:flex-1 justify-start">
                    <a href="https://github.com/Giacomo-De-Luca/YogaSutraTrees/tree/main" target="_blank" class="shadow-xl">
                        <img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Logo" width="30" height="30" class="shadow-xl">
                    </a>
                </div> 
                <div id="titles" class="flex sm:gap-x-4 md:gap-x-6 lg:gap-x-12 justify-around items-center">
                    <a href="https://project-patanjali.gitbook.io/yoga-sutra-trees/" class="text-sm font-semibold leading-6 text-gray-900 hover:text-indigo-600 active:text-violet-700 ">About</a>
                    <button id="saveButton" class="text-sm font-semibold leading-6 text-gray-900 hover:text-indigo-600 active:bg-violet-700 ">Save</button>
                    <button id="load-btn" class="text-sm font-semibold leading-6 text-gray-900 hover:text-indigo-600 active:bg-violet-700 ">Load</button>
                    <button id="advancedSearch" class="text-sm font-semibold leading-6 text-gray-900 hover:text-indigo-600 active:bg-violet-700 ">Advanced Search</button>

                    <input type="file" id="file-input" accept=".json" style="display: none;">             
                    <input type="text" id="nodeSearch" placeholder="Search" class="text-sm bg-transparent  font-semibold text-left" style="width: 55px;">
                </div>
                <div class="flex lg:flex-1 justify-end relative">
                    <button id="sidebarToggle" class="ml-auto z-100 hover:text-indigo-600">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-6 w-6">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                        </svg>
                    </button>
                </div>
            </nav>
        </header>
    </div>



    <div class="flex items-center justify-center min-h-screen">
        <div id="textContainer" class="mx-auto max-w-2xl p-20 bg-white bg-opacity-80 rounded-md">
        <!-- Your existing text content -->
        <div class="text-center">
            <h1 class="text-4xl font-bold tracking-tight text-black sm:text-6xl">Yoga Sutra Trees</h1>
            <p class="mt-6 text-lg leading-8 text-gray-800">A Graph visualization project to explore Patanjali's
                Aphorisms</p>
            <div class="mt-10 flex items-center justify-center gap-x-6">
                <a href="#" onclick="toggleContent()"
                    class="rounded-md bg-indigo-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600">Get
                    started</a>
                <a href="https://project-patanjali.gitbook.io/yoga-sutra-trees/" class="text-sm font-semibold leading-6 text-gray-900 hover:text-indigo-500">Documentation <span>â†’</span></a>
            </div>
        </div>
    </div>
    </div>
</div>
    
    <script>


        document.addEventListener('DOMContentLoaded', function () {
            let cy = null; // Define cy here
            // Load your JSON data (replace 'your-graph.json' with your actual file path)
            
             // Debugging: Print files in the folder
             // fetch('./') // Change './' to the appropriate path if needed
               //   .then(response => response.text())
               //   .then(files => console.log('Files in the folder:', files));
                      
            fetch('graph.json')
                .then(response => response.json()) 
                
                .then(data => {
                    // Initialize Cytoscape
                     cy = cytoscape({
                        container: document.getElementById('cy'),
                        elements: data.elements,
                        userPanningEnabled: true,
                        autoungrabify: false,
    
                        minZoom: 0.07, // the furthest you can zoom out
                        maxZoom: 3, // the furthest you can zoom 
                            
                        style: [
                            {
                                selector: 'node',
                                style: {
    
                                    'label': 'data(id)',
                                    'width': 'label', // Set the width based on the label content
                                    'height': 'label', // Set the height based on the label content
                                    'shape': 'roundrectangle',
                                    'background-color': '#f5f5f5', // Set background color to white
                                    'border-width': 2,                                
                                    'text-wrap': 'wrap',
                                    'text-max-width': 220,
                                    'text-valign': 'center',
                                    'text-halign': 'center',
                                    'color': '#000',
                                    'padding-top': '15px',
                                    'font-family': 'Palatino, Palatino Linotype, serif', // Add this line for font-family
                                    'font-size': 12,
                                    'font-weight': '500',
                                    'border-color': '#5cbcc4', // Set your desired border color
                                    'padding-bottom': '10px', // Add padding to the bottom
                                    
                                }
                            },
                            {
                              selector: 'node[title]', // Only apply to nodes that have the 'title' attribute
                              style: {
                               'text-margin-y': '10px',
                               'padding-bottom': '18px',
                                  
                              }
                          },
                            {
                                selector: 'edge',
                                style: {
                                    'curve-style': 'bezier',
                                    
                                    'target-arrow-shape': 'none',
                                    'width': 5,
                                    'line-color': '#73BDC9',
                                    'target-arrow-color': '#ccc'
                                    
                                }
                            },
                            {
                                selector: 'edge[edgeType = "type2"]',
                                style: {
  
                                    
                                    'curve-style': 'unbundled-bezier',
                                    'control-point-distance': 50, // Adjust this value as needed
                                    'control-point-weight': 0.5,
                                    'control-point-step-size': 40,
                                    'target-arrow-shape': 'none',
                                    'width': 5,
                                    'line-color': '#8BCCE6', // Change this to the color you want for the new type of edge
                                    'target-arrow-color': '#ccc'
                                }
                            },                    
                            {
                                selector: '.blurred',
                                style: {
                                    'opacity': 0.5
                                }
                            },
                            {
                                selector: '.highlighted',
                                style: {
                                    'background-color': '#f0a864'
                                }
                            },
                            {
                                selector: '.spotted',
                                style: {
                                    'background-color': '#f0a864'
                                }
                            }
                            
                           
                        ],
                        
               
                        layout: { 
                            name: 'preset',
                            positions: node => data.positions[node.data('id')]
                        }, // You can use a different layout if needed
                        ready: function() {
                            this.fit(); // Fit the viewport to the graph
                        }
                    });
                    
      
                
    
                    document.getElementById('saveButton').addEventListener('click', function () {
                        // Get the current nodes and edges
                        var nodes = cy.nodes().map(node => ({ data: node.data() }));
                        var edges = cy.edges().map(edge => ({ data: edge.data() }));
                    
                        // Get the current positions
                        var positions = {};
                        cy.nodes().forEach(node => {
                            positions[node.data('id')] = node.position();
                        });
                    
                        // Create a new JSON object
                        var json = {
                            elements: {
                                nodes: nodes,
                                edges: edges
                            },
                            positions: positions
                        };
                    
                        // Convert the JSON object to a string
                        var jsonString = JSON.stringify(json, null, 2);
                    
                        // Create a new Blob object from the JSON string
                        var blob = new Blob([jsonString], { type: 'application/json' });
                    
                        // Create a new object URL for the Blob object
                        var url = URL.createObjectURL(blob);
                    
                        // Create a new link element
                        var link = document.createElement('a');
                    
                        // Set the href of the link to the object URL
                        link.href = url;
                    
                        // Set the download attribute of the link to the desired file name
                        link.download = 'graph.json';
                    
                        // Append the link to the body
                        document.body.appendChild(link);
                    
                        // Simulate a click on the link
                        link.click();
                    
                        // Remove the link from the body
                        document.body.removeChild(link);
                    });

         function handleNodeTap(callback) {
             let sourceNode = null;
             let targetNode = null;
             
             function onTap(event) {
                 if (sourceNode === null) {
            sourceNode = event.target;
        } else {
            targetNode = event.target;
            if (sourceNode.id() !== targetNode.id()) {
                callback(sourceNode, targetNode);
            }
            sourceNode = null;
            targetNode = null;
            cy.nodes().off('tap', onTap);
        }
    }

    cy.nodes().on('tap', onTap);
}

// Event listener for the "Add Link" button
document.getElementById('add-link-btn').addEventListener('click', function () {
    handleNodeTap((sourceNode, targetNode) => {
        cy.add({ data: { source: sourceNode.id(), target: targetNode.id() } });
    });
});

// Event listener for the "Remove Link" button
document.getElementById('remove-link-btn').addEventListener('click', function () {
    handleNodeTap((sourceNode, targetNode) => {
        var edges = cy.edges().filter(edge => {
            return (edge.source().id() === sourceNode.id() && edge.target().id() === targetNode.id()) ||
            (edge.source().id() === targetNode.id() && edge.target().id() === sourceNode.id());
        });
        if (edges.length > 0) {
            edges.remove();
        }
    });
});

                let detailsContent = "";


                
                function openLeftSidebar(node) {
                    const nodeId = node.id();
                    var leftSidebar = document.getElementById('leftSidebar');
                    leftSidebar.style.transform = "translateX(0)";
                    leftSidebar.style.boxShadow = "1px 0px 3px 0px rgba(0,0,0,0.3)"; 

                    // Check if displaySelector is initialized and has selected options
                    if ($.fn.select2 && $('#displaySelector').data('select2')) {
                        // Get the selected attributes
                        const selectedAttributes = $('#displaySelector').select2('data').map(option => option.id);
                        
                        // Build the additional details content using the selected attributes
                        selectedAttributes.forEach(attribute => {
                            if (node.data(attribute)) {
                                detailsContent += `<p><strong>${attribute}:</strong> ${node.data(attribute)}</p>`;
                            }
                        });
                    };
                    

                        // Display comments in the comments section
                        const commentsSection = document.getElementById('commentsSection');
                        commentsSection.innerHTML = `<strong>Comments:</strong> ${node.data('comment') || ''}`;
                        
                        
                        // Display title in the title section
                        const titleSection = document.getElementById('titleSection');
                        titleSection.innerHTML = `${node.data('title') || 'Title'}`;
                        
                        
                        // Display tags in the tags section
                        const tagsSection = document.getElementById('tagsSection');
                        tagsSection.innerHTML = `<strong>Tags:</strong> ${node.data('tags') || ''}`;
                        
                        // Display references in the references section
                        const referencesSection = document.getElementById('referencesSection');
                        referencesSection.innerHTML = `<strong>References:</strong> ${node.data('references') || ''}`;

                        currentOpenNodeId = nodeId;

                        commentsSection.addEventListener('dblclick', function () {
                            makeCommentsEditable(commentsSection);
                        });
                        
                        titleSection.addEventListener('dblclick', function () {
                            makeTitleEditable(titleSection);
                        });
                    
                        tagsSection.addEventListener('dblclick', function () {
                            makeTagsEditable(tagsSection);
                        });

                        referencesSection.addEventListener('dblclick', function () {
                            makeReferencesEditable(referencesSection);
                        });
                    }

                const searchInput = document.getElementById('nodeSearch');
                const matchCountDisplay = document.getElementById('matchCount');
                
                searchInput.addEventListener('input', function() {
                    const searchText = searchInput.value.trim().toLowerCase();
                    let matchCount = 0;
                
                    // First, remove all temporary edges
                    cy.edges('.temporary-text').remove();
                
                    // If the search text is empty, remove the 'highlighted' and 'blurred' classes from all nodes and return
                    if (searchText === '') {
                        cy.nodes().removeClass('highlighted blurred');
                        return;
                    }
                
                    // Get the nodes that match the search text
                    const matchedNodes = cy.nodes().filter(node => {
                        const nodeId = node.data('id').toLowerCase();
                        const nodeLabel = node.data('Sanskrit_Text').toLowerCase();
                        const translationBryant = node.data('Translation_Bryant').toLowerCase();
                
                        // Check if any of the fields contains the search text
                        if (nodeId.includes(searchText) || nodeLabel.includes(searchText) || translationBryant.includes(searchText)) {
                            // Add the 'highlighted' class and remove the 'blurred' class
                            node.addClass('highlighted');
                            node.removeClass('blurred');
                            matchCount++;
                            return true;
                        } else {
                            // Add the 'blurred' class and remove the 'highlighted' class
                            node.addClass('blurred');
                            node.removeClass('highlighted');
                            return false;
                        }
                    });
                
                    // Create temporary edges between the matched nodes
                    matchedNodes.forEach(function (node, index) {
                        for (let i = index + 1; i < matchedNodes.length; i++) {
                            const otherNode = matchedNodes[i];
                            cy.add({
                                group: 'edges',
                                data: { source: node.id(), target: otherNode.id() },
                                classes: 'temporary-text',
                                style: { 'line-color': '#CFC8FA' } // Change this to the color you want
                            });
                        }
                    });
                });




                document.getElementById('load-btn').addEventListener('click', function () {
                    document.getElementById('file-input').click();
                });
                document.getElementById('file-input').addEventListener('change', function (e) {
                    var file = e.target.files[0];
                    if (!file) {
                        return;
                    }
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        var contents = e.target.result;
                        var data = JSON.parse(contents);

                        // Reconfigure the graph
                        cy.elements().remove();
                        cy.add(data.elements);
                        cy.nodes().forEach(node => {
                            node.position(data.positions[node.data('id')]);
                        });
                    };
                    reader.readAsText(file);
                });


                let select = document.getElementById('tagSelect');
                
                $(select).select2({
                    tags: true,
                    tokenSeparators: [','],
                    placeholder: 'Select tags',
                    templateResult: formatTag,
                    templateSelection: formatTag
                });
                
                // Define the formatTag function
                function formatTag(tag) {
                    var $tag = $('<span><i class="tag-color"></i> ' + tag.text + '</span>');
                    $tag.find('.tag-color').css({
                        'background-color': tagColors[tag.text] || '#000',
                        'display': 'inline-block',
                        'width': '10px',
                        'height': '10px',
                        'margin-right': '5px'
                    });
                    return $tag;
                }
                
                // Define the color palette
                const colorPalette = ['#DBD788', '#DB9B88', '#88DBC5', '#A588DB', '#839993'];
                
                
                function getRandomDesaturatedColor() {
                    // Function to generate a random desaturated color
                    const randomHue = Math.random() * 360;
                    const randomSaturation = 20 + Math.random() * 60; // Adjust the saturation range as needed
                    const randomLightness = 50 + Math.random() * 30; // Adjust the lightness range as needed

                    return `hsl(${randomHue}, ${randomSaturation}%, ${randomLightness}%)`;
                }

                function getRandomDesaturatedHex() {
                    // Function to generate a random desaturated color
                    const randomHue = Math.random();
                    const randomSaturation = 0.2 + Math.random() * 0.6; // Adjust the saturation range as needed
                    const randomLightness = 0.5 + Math.random() * 0.3; // Adjust the lightness range as needed

                    // Convert HSL to RGB
                    let r, g, b;
                    if(randomSaturation === 0){
                        r = g = b = randomLightness; // achromatic
                    } else {
                        const hue2rgb = function hue2rgb(p, q, t){
                            if(t < 0) t += 1;
                            if(t > 1) t -= 1;
                            if(t < 1/6) return p + (q - p) * 6 * t;
                            if(t < 1/2) return q;
                            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        }
                        const q = randomLightness < 0.5 ? randomLightness * (1 + randomSaturation) : randomLightness + randomSaturation - randomLightness * randomSaturation;
                        const p = 2 * randomLightness - q;
                        r = hue2rgb(p, q, randomHue + 1/3);
                        g = hue2rgb(p, q, randomHue);
                        b = hue2rgb(p, q, randomHue - 1/3);
                    }

                    // Convert RGB to hexadecimal and return
                    return "#" + [r, g, b].map(x => {
                        const hex = Math.round(x * 255).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');
                }
                                
                
                function getRandomHexColor() {
                    let letters = "0123456789ABCDEF";
                    let color = '#';
                    
                    for (let i = 0; i < 6; i++) {
                        color += letters[Math.floor(Math.random() * 16)];
                    }
                    
                    return color;
                }
                                                    
                // Create a mapping from tags to colors
                
                let tagColors = {};
                let colorIndex = 0;
                cy.nodes().forEach(function (node) {
                    const nodeTags = node.data('tags') ? node.data('tags').split(', ') : [];
                    nodeTags.forEach(tag => {
                        if (!tagColors[tag]) {
                                                    if (colorIndex < 6) {
                                tagColors[tag] = colorPalette[colorIndex];
                            } else {
                                // Assign a random desaturated color for each tag


                                tagColors[tag] = getRandomDesaturatedHex()
                                
                            }
                            colorIndex++;
                        }
                    });
                });
                
                // Add event listener
                $(select).on('change', function () {
                    const selectedTags = $(this).select2('data').map(option => option.text);
                    if (selectedTags.length > 0) {
                        filterNodesByTag(selectedTags);
                    } else {

                        // Reset all nodes to their default color
                        
                        cy.edges('.temporary-tag').remove();
                        cy.nodes().removeClass('filtered highlighted blurred');
                        resetNodesToModifiedColor();
                    }
                });
                
                updateDropdownOptions();

                function filterNodesByTag(selectedTags) {
                    

                    // First, remove all temporary edges
                    cy.edges('.temporary-tag').remove();
                
                    // Reset all nodes to their default color
                    resetNodesToModifiedColor();
                
                    // If no tags are selected, remove the 'blurred' class from all nodes and return
                    if (selectedTags.length === 0) {
                        cy.nodes().removeClass('blurred');
                        return;
                    }
                
                    cy.nodes().addClass('blurred');
                
                    // Get the nodes that have at least one of the selected tags
                    const selectedNodes = cy.nodes().filter(function (node) {
                        
                        const nodeTags = node.data('tags') ? node.data('tags').split(', ') : [];
                        const nodeSelectedTags = nodeTags.filter(tag => selectedTags.includes(tag));
                        return nodeSelectedTags.length > 0;
                    });
                
                    // For each selected node
                    selectedNodes.forEach(function (node, index) {
                        const nodeTags = node.data('tags') ? node.data('tags').split(', ') : [];
                        const nodeSelectedTags = nodeTags.filter(tag => selectedTags.includes(tag));
                        const nodeSelectedColors = nodeSelectedTags.map(tag => tagColors[tag]);
                        node.style('background-color', mixColors(nodeSelectedColors));
                        node.removeClass('blurred'); // Remove the 'blurred' class

                        // Create temporary edges between this node and all other selected nodes that share at least one tag
                        for (let i = index + 1; i < selectedNodes.length; i++) {
                            const otherNode = selectedNodes[i];
                            const otherNodeTags = otherNode.data('tags') ? otherNode.data('tags').split(', ') : [];
                            const sharedTags = otherNodeTags.filter(tag => nodeSelectedTags.includes(tag));

                            if (sharedTags.length > 0) {
                                cy.add({
                                    group: 'edges',
                                    data: { source: node.id(), target: otherNode.id() },
                                    classes: 'temporary-tag',
                                    style: { 'line-color': desaturateColor(mixColors(nodeSelectedColors)) }
                                });
                            }
                        }                    
                    });
                }

                function mixColors(colors) {
                    let r = 0;
                    let g = 0;
                    let b = 0;
                
                    colors.forEach(color => {
                        r += parseInt(color.slice(1, 3), 16);
                        g += parseInt(color.slice(3, 5), 16);
                        b += parseInt(color.slice(5, 7), 16);
                    });
                
                    r = Math.floor(r / colors.length);
                    g = Math.floor(g / colors.length);
                    b = Math.floor(b / colors.length);
                
                    return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
                }

                function desaturateColor(color) {
                    // Parse the RGB components from the color
                    let r = parseInt(color.slice(1, 3), 16);
                    let g = parseInt(color.slice(3, 5), 16);
                    let b = parseInt(color.slice(5, 7), 16);

                    // Increase luminosity by 50%, ensuring it doesn't exceed 255
                    r = Math.min(Math.floor(r * 1.3), 255);
                    g = Math.min(Math.floor(g * 1.3), 255);
                    b = Math.min(Math.floor(b * 1.3), 255);

                    // Return the color in hexadecimal format
                    return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
                }
                
                
                // Function to handle the search action
                function handleSearch() {
                    // Remove the 'highlighted' class from all nodes
                    cy.nodes().removeClass('highlighted');
                    
                    // Get the node ID from the input field
                    var nodeId = document.getElementById('node-id-input').value;
                    // If the input field is not empty
                    if (nodeId) {
                        // Find the node in the Cytoscape graph
                        var node = cy.getElementById(nodeId);
                        // Check if the node exists
                        if (node.length > 0) {
                            // Highlight the node
                            node.addClass('highlighted');
                            // Call the openLeftSidebar function
                            updateDetailsID(nodeId)
                        } else {
                            alert('Node not found');
                        }
                    }
                }
                
                // Event listener for the Enter key on the input field
                document.getElementById('node-id-input').addEventListener('keypress', function (e) {
                    // Check if the Enter key was pressed
                    if (e.key === 'Enter') {
                        handleSearch();
                    }
                });

                const colorPickerNodes = document.getElementById('color-picker-nodes');
                const colorPickerBorder = document.getElementById('color-picker-border');
                const colorPickerEdges = document.getElementById('color-picker-edges');
                const colorPickerHighlight = document.getElementById('color-picker-highlight');


                var spottedColor = "#D29165";   



                // Change node colour background
                colorPickerNodes.addEventListener('change', function () {
                    // Get the selected color
                    const color = this.value;
                    
                    // Change the styles of the nodes
                    cy.style()
                    .selector('node')
                    .style({
                        'background-color': color,
                    })
                    .selector('.spotted')
                    .style({
                        'background-color': spottedColor,
                    })
                    
                    .selector('.highlighted')
                    .style({
                        'background-color': '#E0CD9F'
                    })    

                        
                    .update(); // Apply the changes
                });

                   // Change colour border
                   colorPickerBorder.addEventListener('change', function () {
                    // Get the selected color
                    const color = this.value;
                    
                    // Change the styles of the nodes
                    cy.style()
                    .selector('node')
                    .style({
                        'border-color': color,
                    })
                    .update(); // Apply the changes
                });

                   // Change colour edges
                   colorPickerEdges.addEventListener('change', function () {
                    // Get the selected color
                    const color = this.value;
                    
                    // Change the styles of the edges
                    cy.style()
                    .selector('edge')
                    .style({
                        'line-color': color,
                    })
                    .update(); // Apply the changes
                });

                   // Change highlight on select
                   colorPickerHighlight.addEventListener('change', function () {
                    // Get the selected color
                    const color = this.value;
                    
                    // Change the styles of the highlight on selection
                    cy.style()
                    .selector('.spotted')
                    .style({
                        'background-color': color,
                    })
                    .update();  // Apply the changes
                    
                    spottedColor = color
                });
                
                function resetNodesToModifiedColor() {
                     // Get all nodes in the graph
                      const allNodes = cy.nodes();

                      // Iterate through all nodes
                      allNodes.forEach(node => {
                        const nodeId = node.id();
                        const modifiedColor = modifiedNodeColors.get(nodeId);

                        if (modifiedColor !== undefined) {
                             // If the node has a modified color, set it
                              node.style('background-color', modifiedColor);
                            } else {
                              // If the node doesn't have a modified color, reset to base color

                             node.style('background-color', '');
                            }
                          });
                        }
                      

                function makeTagsEditable(element) {
                    const nodeId = currentOpenNodeId;
                    const node = cy.$id(nodeId);
                    const tags = node.data('tags') ? node.data('tags').split(', ') : [];
                
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = tags.join(', ');
                    input.onblur = function () {
                        const newTags = input.value.split(', ');
                        node.data('tags', newTags.join(', '));
                        element.innerHTML = `<strong>Tags:</strong> ${newTags.join(', ')}`;
                        updateDropdownOptions();
                    };
                
                    element.innerHTML = '';
                    element.appendChild(input);
                    input.focus();
                }

                function makeCommentsEditable(element) {
                    const nodeId = currentOpenNodeId;
                    const node = cy.$id(nodeId);
                    const comments = node.data('comment') || '';
                
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = comments;
                    input.onblur = function () {
                        const newComments = input.value;
                        node.data('comment', newComments);
                        element.innerHTML = `<strong>Comments:</strong> ${newComments}`;
                    };
                
                    element.innerHTML = '';
                    element.appendChild(input);
                    input.focus();
                } 
                
                function makeTitleEditable(element) {
                    const nodeId = currentOpenNodeId;
                    const node = cy.$id(nodeId);
                    const comments = node.data('title') || '';
                
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = comments;
                    input.onblur = function () {
                        const newTitle = input.value;
                        node.data('title', newTitle);
                        element.innerHTML = `${newTitle}`;
                    };
                
                    element.innerHTML = '';
                    element.appendChild(input);
                    input.focus();
                }

                function createInflectionTable(inflection_wordsIAST, rowcolstitles) {

                    if (!inflection_wordsIAST || !Array.isArray(inflection_wordsIAST)) {
                        return '';
                    }
                    
                      // Check if inflection_wordsIAST has length 0 or 1
                    if (inflection_wordsIAST.length <= 1) {
                        return "<b>indeclinable</b>";
                    }

                    // Define row and column titles
                    let rowtitles = ["First", "Second", "Third"];
                    let coltitles = ["Sg", "Du", "Pl"];

                    // Check the number of words in inflection_wordsIAST
                    if (inflection_wordsIAST.length === 24) {
                        rowtitles = ["Nom", "Acc", "Inst", "Dat", "Abl", "Gen", "Loc", "Voc"];
                    }

                    // Split the list into a table
                    let table = [];
                    for (let i = 0; i < inflection_wordsIAST.length; i += coltitles.length) {
                        table.push(inflection_wordsIAST.slice(i, i + coltitles.length));
                    }

                    // Move 'Voc' row and its values to the second row
                    if (inflection_wordsIAST.length === 24) {
                        let vocIndex = rowtitles.indexOf('Voc');
                        let vocRow = table.splice(vocIndex, 1)[0];
                        table.splice(1, 0, vocRow);
                        rowtitles.splice(vocIndex, 1);
                        rowtitles.splice(1, 0, 'Voc');
                    }

                    // Create a map for bold cells
                    let boldMap = {};
                    if (!Array.isArray(rowcolstitles)) {
                        console.error('rowcolstitles is not an array:', rowcolstitles);
                        return;
                    }
                    for (let rowcol of rowcolstitles) {
                        let [row, col] = rowcol;
                        if (!boldMap[row]) {
                            boldMap[row] = {};
                        }
                        boldMap[row][col] = true;
                    }

                    // Create the HTML table
                    let output = `<table border="1"><tr><th></th>`;
                    for (let title of coltitles) {
                        output += `<th>${title}</th>`;
                    }
                    output += `</tr>`;
                    for (let i = 0; i < table.length; i++) {
                        output += `<tr><td>${rowtitles[i]}</td>`;
                        for (let j = 0; j < table[i].length; j++) {
                            let cell = table[i][j];
                            if (boldMap[rowtitles[i]] && boldMap[rowtitles[i]][coltitles[j]]) {
                                output += `<td><b>${cell}</b></td>`;
                            } else {
                                output += `<td>${cell}</td>`;
                            }
                        }
                        output += `</tr>`;
                    }
                    output += `</table>`;

                    return output;
                }

                function makeReferencesEditable(element) {
                    const nodeId = currentOpenNodeId;
                    const node = cy.$id(nodeId);
                    const references = node.data('references') ? node.data('references').split(', ') : [];
                
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = references.join(', ');
                    input.onblur = function () {
                        const newReferences = input.value.split(', ');
                        node.data('references', newReferences.join(', '));
                        element.innerHTML = `<strong>References:</strong> ${newReferences.join(', ')}`;
                    };
                
                    element.innerHTML = '';
                    element.appendChild(input);
                    input.focus();
                }

                function updateDropdownOptions() {
                    const select = document.getElementById('tagSelect');
                    select.innerHTML = '';
                
                    const uniqueTags = new Set();
                    cy.nodes().forEach(function (node) {
                        const nodeTags = node.data('tags') ? node.data('tags').split(', ') : [];
                        nodeTags.forEach(tag => uniqueTags.add(tag));
                    });
                
                    const tagsArray = Array.from(uniqueTags);
                    tagsArray.forEach(tag => {
                        let option = document.createElement('option');
                        option.value = tag;
                        option.text = tag;
                        select.appendChild(option);
                
                        // If the tag doesn't have a color yet, assign it one
                        if (!tagColors[tag]) {
                            if (colorIndex < 6) {
                                tagColors[tag] = colorPalette[colorIndex];
                            } else {
                                // Assign a random desaturated color for each tag
                                
                                tagColors[tag] = getRandomDesaturatedHex();
                            }
                            colorIndex++;
                        }
                    });          
                }

                const nodes = cy.nodes();
                
                // Get the unique attributes from all nodes
                let nodeAttributes = [];
                nodes.forEach(node => {
                    nodeAttributes = [...nodeAttributes, ...Object.keys(node.data())];
                });
                nodeAttributes = [...new Set(nodeAttributes)]; // Remove duplicates

                 
                // Get the select element
                const attributeSelector = $('#attributeSelector');

                document.getElementById('cy').style.display = "none";

                // Initialize Select2 for the attributeSelector dropdown
                attributeSelector.select2({
                    placeholder: 'Select attributes',
                    allowClear: true,
                    closeOnSelect: false
                });

      
          

                // Populate the dropdown with options
                nodeAttributes.forEach(attribute => {
                    const isSelected = ['id','Sanskrit_Text', 'Translation_Bryant'].includes(attribute);
                    const option = new Option(attribute, attribute, isSelected, isSelected);
                    attributeSelector.append(option);
                });

                // Add the label function inside the style array
                cy.style().selector('node').style({
                    'label': function(ele) {
                        // Get the selected attributes
                        const selectedAttributes = $('#attributeSelector').select2('data').map(option => option.id);
                        // Build the label using the selected attributes
                        let label = '\n\n\n\n\n\n';
                        selectedAttributes.forEach(attribute => {
                            if (ele.data(attribute)) {
                                label += ele.data(attribute) + '\n\n';
                            }
                        });
                        return label;
                    },
                    // Your other styles here
                });
                
                                
             // Add nodeHtmlLabel for custom HTML labels
                cy.nodeHtmlLabel([{
                    query: 'node[title]',
                    valign: 'top', // Align to the top
                    halign: 'center',
                    valignBox: 'center',
                    halignBox: 'center',
                    tpl: function (data) {
                        const title = data.title; // Assuming 'title' is the attribute you want to display

                        // Display only the title in bold, centered, and on the upper part of the node
                        return '<div style="font-family: Palatino, Palatino Linotype, serif; font-size: 12px; font-weight: bold; text-align: center; max-width: 200px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;">' + title + '</div>';
                    }
                }]);



                // Update the Cytoscape styles whenever the selected options change
                $('#attributeSelector').on('change', function() {
                    cy.style().update(); // This will force Cytoscape to reapply the styles
                });
                
                // Get the select element for the display
                const displaySelector = $('#displaySelector');
                
                
                // Populate the dropdown with options
                nodeAttributes.forEach(attribute => {
                    // Exclude 'tags', 'references', and 'comment' fields
                    if (!['tags', 'references', 'comment'].includes(attribute)) {
                        const isSelected = ['Sanskrit_Text', 'Translation_Bryant', 'Word_for_Word_Analysis', 'Vyasa_sanskrit'].includes(attribute);
                        const option = new Option(attribute, attribute, isSelected, isSelected);
                        displaySelector.append(option);
                    }
                });

                // Initialize Select2 for the attributeSelector dropdown
                displaySelector.select2({
                    placeholder: 'Select attributes',
                    allowClear: true,
                    closeOnSelect: false
                }).on('select2:opening', function(e) {
                    // Stop the mousedown event from propagating to Cytoscape
                    e.stopPropagation();
                });

                 // Store the currently selected node
                 let selectedNode = null;
    
                
            // Get the modal
            var modal = document.getElementById("searchModal");

            // Get the button that opens the modal
            var btn = document.getElementById("advancedSearch");

            // Get the <span> element that closes the modal
            var span = document.getElementsByClassName("close")[0];

            // When the user clicks the button, open the modal 
            btn.onclick = function() {
            modal.style.display = "block";
            }

            // When the user clicks on <span> (x), close the modal
            span.onclick = function() {
            modal.style.display = "none";
            }

            // When the user clicks anywhere outside of the modal, close it
            window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
            }
            function kyotoToIAST(text) {
                return text.replace(/A/g, 'Ä').replace(/I/g, 'Ä«').replace(/U/g, 'Å«')
                        .replace(/R/g, 'á¹›').replace(/RR/g, 'á¹').replace(/L/g, 'á¸·')
                        .replace(/LL/g, 'á¸¹').replace(/M/g, 'á¹ƒ').replace(/N/g, 'á¹‡')
                        .replace(/H/g, 'á¸¥').replace(/L/g, 'á¸·').replace(/\"n/g, 'á¹…')
                        .replace(/J/g, 'Ã±').replace(/z/g, 'Å›').replace(/S/g, 'á¹£');
            }

            // Function to generate bigrams of words
            function generateBigrams(text, input) {
                var stopWords = ["the", "be", "to", "of", "and", "a", "in", "that", "have", "I", "it", "for", "not", "on", "with", "he", "as", "you", "do", "at"]; // Add more stop words as needed

                var words = text.split(/[\s-]+/).filter(word => !stopWords.includes(word.toLowerCase()));

                var bigrams = [];
                for (var i = 0; i < words.length; i++) {
                    if (words[i].includes(input)) {
                        if (i > 0) { // If there is a preceding word
                            bigrams.push(words[i - 1] + ' ' + words[i]);
                        }
                        if (i < words.length - 1) { // If there is a following word
                            bigrams.push(words[i] + ' ' + words[i + 1]);
                        }
                    }
                }
                return bigrams;
            }


            // Get the select element for the advanced search
            const advancedSearchSelector = $('#advancedSearchSelector');

            // Populate the dropdown with options
            nodeAttributes.forEach(attribute => {
                const isSelected = ['id','Sanskrit_Text', 'Translation_Bryant', 'Vyasa_sanskrit'].includes(attribute);
                const option = new Option(attribute, attribute, isSelected, isSelected);
                advancedSearchSelector.append(option);
            });


            // Initialize Select2 for the advancedSearchSelector dropdown
            advancedSearchSelector.select2({
                placeholder: 'Select attributes',
                allowClear: true,
                closeOnSelect: false
            }).on('select2:opening', function(e) {
                // Stop the mousedown event from propagating to Cytoscape
                e.stopPropagation();
            }).on('change', function(e) {
                    // Call updateAverageLength whenever the dropdown selection changes
            });

            function createVisualization(data, cy) {



                  

              }   




            function advancedSearch(searchText) {
                searchText = searchText.trim();
                            
                const selectedAttributes = Array.from(document.getElementById('advancedSearchSelector').selectedOptions).map(option => option.value);

                // Split the search text into multiple queries
                var searchQueries = searchText.split(/[,;]/).map(query => kyotoToIAST(query.trim()));

                // Log the transliterated search text
                console.log('Transliterated search text:', searchQueries);
                var wordFrequency = {}; // Map to store word frequency


                // Perform the search
                var results = [];
                cy.nodes().forEach(function(node) {
                    for (var attr of selectedAttributes) {
                        if (node.data(attr)) {
                            var nodeData = node.data(attr).toString().toLowerCase();
                            // Check if all of the search queries are included in the node data
                            if (searchQueries.every(query => nodeData.includes(query))) {
                                results.push(node);
                                break;
                            }
                            // Split node data into words and update frequency map
                            nodeData.split(' ').forEach(word => {
                                word = word.replace(/[.,]$/, '').trim().toLowerCase(); // Remove final '.' and trim
                                wordFrequency[word] = (wordFrequency[word] || 0) + 1;
                            });

                        }
                    }
                });



                                
                // Remove 'highlight' class from all nodes
                cy.nodes().removeClass('highlighted');

                // Display the results
                var searchResults = document.getElementById('searchResults');
                var nodeAttributes = document.getElementById('nodeAttributes');

                searchResults.innerHTML = 'Found ' + results.length + ' results:<br>' + results.map(node => '<a href="#" class="node-link" data-id="' + node.id() + '">' + node.id() + '</a>').join(', ');

                
                // Add 'highlight' class to the matching nodes
                results.forEach(node => node.addClass('highlighted'));


             // Load your dictionary
            var dictionary = {}; // Replace this with your actual dictionary
            fetch('MWIastKey.json')
                .then(response => response.json())
                .then(data => dictionary = data);   

                
               // Add event listener to node-link elements
                searchResults.addEventListener('click', function(event) {
                    if (event.target.classList.contains('node-link')) {
                        var nodeId = event.target.getAttribute('data-id');
                        var node = cy.nodes().filter(node => node.id() === nodeId);
                        var text = selectedAttributes.map(attr => {
                            var attrValue = node.data(attr);
                            if (typeof attrValue === 'string') {
                                // Split and wrap the words
                                var words = attrValue.split(' ');
                                var wrappedText = words.map(word => `<span class="word">${word}</span>`).join(' ');

                                // Replace searched words with highlighted version
                                var regex = new RegExp(searchQueries, 'gi');
                                wrappedText = wrappedText.replace(regex, '<span class="word" style="background-color: turquoise;">$&</span>');

                                attrValue = wrappedText;
                            }
                            return attrValue;
                        }).join(', ');

                        nodeAttributes.innerHTML = text;

                        var wordElements = document.querySelectorAll('.word');

                        wordElements.forEach(wordElement => {
                            wordElement.addEventListener('click', function(event) {
                                event.preventDefault();

                                // Show the custom context menu
                                var contextMenu = document.getElementById('custom-context-menu');
                                contextMenu.style.display = 'block';
                                contextMenu.style.right = '10%';
                                contextMenu.style.top = '50%';

                                // Get the word
                                var word = event.target.textContent;


                                console.log('Sending request with word:', word);  // Print message when request is sent
                                fetch('http://127.0.0.1:5000/process', {
                                    method: 'POST',
                                    headers: { 
                                        'Content-Type': 'text/plain'
                                    },
                                    body: word
                                })
                                .then(response => {
                                    console.log('Received response');  // Print message when response is received
                                    return response.json();
                                })


                            // Then in your fetch call:
                            .then(data => {
                                //debugging
                                console.log('Response data:', data);
                                let output = '';
                                data.forEach(entry => {

                                    if (entry.length === 3) {
                                            output += `<h1 class="text-xl" style="font-family:Garamond; font-weight:bold;">${entry[0]}</h1>`;
                                            if (entry[0] !== entry[1]) {
                                            output +=`<p class="font-style: italic;" style="font-family:Garamond;">${entry[5]}</p>`;
                                            }                                                  // Dictionary
                                            if (entry[2]) {
                                                let vocabEntries = entry[2].join('<br>').replace(/<s>(.*?)<\/s>/g, '<span style="font-style:italic;">$1</span>');
                                                output += `<p>Vocabulary entries: <br>${vocabEntries}</p>`;
                                            } else {
                                                output += `<p>Vocabulary entries: None</p>`;
                                            }
                                            output += '<hr>';  // Add a horizontal line for readability

                                    } else {

                                    
                                    //title
                                    output += `<h1 class="text-xl" style="font-family:Garamond; font-weight:bold;">${entry[0]}</h1>`;
                                    //costituents, shows only if there are some
                                    if (entry[0] !== entry[5]) {
                                            output +=`<p class="font-style: italic;" style="font-family:Garamond;">${entry[5]}</p>`;
                                        }                                        
                                    //original word
                                    if (entry[0] !== entry[4]) {
                                        output += `<p><span style="font-family:Garamond;">from:</span> <span style="font-family:Garamond; font-style: italic;">${entry[4]}</span></p>`;                                        }
                                    //word type (noun, verb, etc.)
                                    output += `<p>${entry[1]}</p>`;
                                    //inflection


                                    if (entry[2]) {
                                        entry[2].forEach((inflection, index) => {
                                            let caseAbbr = inflection[0];
                                            let numberAbbr = inflection[1];

                                            let caseFull = caseAbbr.split(',').map(abbr => {
                                                switch (abbr.trim()) {
                                                    case 'Nom': return 'Nominative';
                                                    case 'Acc': return 'Accusative';
                                                    case 'Voc': return 'Vocative';
                                                    case 'Ins': return 'Instrumental';
                                                    case 'Dat': return 'Dative';
                                                    case 'Abl': return 'Ablative';
                                                    case 'Gen': return 'Genitive';
                                                    case 'Loc': return 'Locative';
                                                    default: return abbr;
                                                }
                                            }).join(', ');

                                            let numberFull = numberAbbr.split(',').map(abbr => {
                                                switch (abbr.trim()) {
                                                    case 'Sg':  return 'Singular';
                                                    case 'Du':  return 'Dual';
                                                    case 'Pl':  return 'Plural';
                                                    default: return abbr;
                                                }
                                            }).join(', ');

                                            output += `<span style="font-family:Garamond; font-style: italic;">${caseFull}, ${numberFull}</span>`;
                                            if (index < entry[2].length - 1) {
                                                output += `<span> or </span>`;
                                            }
                                        });
                                    }                                    
                                    //inflection table
                                    output += `<p>Inflection table:</p>`;
                                    output += createInflectionTable(entry[3], entry[2]);
                                    if (entry[6]) {
                                            let vocabEntries = entry[6].join('<br>').replace(/<s>(.*?)<\/s>/g, function(match, p1) {
                                                return `<span class="vocab-entry" style="font-style:italic; color: teal;" data-word="${p1}">${p1}</span>`;
                                            });
                                            output += `<p>Vocabulary entries: <br>${vocabEntries}</p>`;
                                        } else {
                                            output += `<p>Vocabulary entries: None</p>`;
                                        }
                                        output += '<hr>';  // Add a horizontal line for readability
                                    }
                                });
                                document.getElementById('context_menu_text').innerHTML = output;
                            })
                            .catch((error) => {
                                console.error('Error:', error);
                            });

                            document.addEventListener('click', function(e) {
                                if (e.target.classList.contains('vocab-entry')) {
                                    let word = e.target.dataset.word;
                                    console.log('Word:', word);  // Log the word
                                    fetch('/dict_entry', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({ word: word })
                                    })
                                    .then(response => {
                                        console.log('Response:', response);  // Log the response
                                        return response.json();
                                    })
                                    .then(data => {
                                    console.log('Data:', data);  // Log the data
                                    if (Array.isArray(data)) {
                                        // Handle the data here
                                        let newEntry = document.createElement('p');
                                        newEntry.innerHTML = data.join('<br>').replace(/<s>(.*?)<\/s>/g, '<span style="font-style:italic; color: teal;">$1</span>');
                                        e.target.parentNode.appendChild(newEntry);
                                    } else {
                                        console.error('Error: Expected an array but received', data);
                                    }
                                })
                                .catch(error => console.error('Error:', error));
                                }
                            });
                            });
                        });
                    }
                });

                  // Prepare data for visualization
                  var data = cy.nodes().map(node => {
                        var matchCount = 0;
                        var attrLength = 0;
                        for (var attr of selectedAttributes) {
                            if (node.data(attr)) {
                                var attrValue = node.data(attr).toString();
                                if (searchQueries.every(query => attrValue.includes(query))) {
                                    matchCount++;
                                }
                                attrLength += attrValue.length;
                            }
                        }
                        return {
                            id: node.id(),
                            match: matchCount,
                            length: attrLength
                        };
                        });

                        function updateAverageLength() {

                                // Calculate average length of selected attributes text
                                var totalLength = 0;
                                var count = 0;
                                cy.nodes().forEach(function(node) {
                                    for (var attr of selectedAttributes) {
                                        if (node.data(attr)) {
                                            totalLength += node.data(attr).toString().length;
                                            count++;
                                        }
                                    }
                                });
                                var averageLength = totalLength / count;
                                // console.log('averageLength:', averageLength);

                                return averageLength;

                                }   



                                // Calculate total text length
                                var totalTextLength = 0;
                                data.forEach(function(d) {
                                totalTextLength += d.length;
                                });

                                var averageLength = totalTextLength / data.length;


                                // Define color scale
                                var colorScale = d3.scaleLinear()
                                .domain([0, d3.max(data, d => d.match)])
                                .range(["#D3D3D3", "#40E0D0" ]);

                                // Remove existing SVG container
                                d3.select("#graphicPlot svg").remove();

                                // Create SVG container
                                var svg = d3.select("#graphicPlot").append("svg")
                                .attr("width", 1000)
                                .attr("height", 100); // Increase height to accommodate more rows

                                // Create tooltip
                                var tooltip = d3.select("body").append("div")
                                .attr("class", "tooltip")
                                .style("opacity", 0)
                                .style("z-index", "10"); 

                                // Define box size and number of boxes per row
                                // Define box size
                                var boxSize = 15;
                                var boxAmplitude = 15;


                                // Calculate cumulative widths and row numbers
                                // Calculate cumulative widths and row numbers
                                var cumulativeWidths = [];
                                var rowNumbers = [];
                                var rowMaxBoxes = [51, 53, 54]; // Maximum number of boxes in each row
                                var currentRow = 0;
                                var currentWidth = 0;
                                var currentBox = 0;

                                for (var i = 0; i < data.length; i++) {
                                var boxWidth = data[i].length / averageLength * boxAmplitude;
                                if (currentBox >= (rowMaxBoxes[currentRow] || 55)) {
                                    // Start a new row
                                    currentRow++;
                                    currentWidth = 0;
                                    currentBox = 0;
                                }
                                cumulativeWidths[i] = currentWidth;
                                rowNumbers[i] = currentRow;
                                currentWidth += boxWidth;
                                currentBox++;
                                }

                                svg.selectAll("rect")
                                .data(data)
                                .enter()
                                .append("rect")
                                .attr("x", (d, i) => {
                                    return cumulativeWidths[i];
                                })
                                .attr("y", (d, i) => {
                                    return rowNumbers[i] * boxSize;
                                })


                                .attr("width", d => (d.length / averageLength) * boxAmplitude) // Set width based on text length
                                .attr("height", boxSize) // Set height to boxSizesize based on text length
                                .style("fill", d => colorScale(d.match)) // Use color scale based on number of matches
                                .style("stroke", "black")
                                .style("stroke-width", 1)
                                .on("mouseover", function(d) {
                                    tooltip.transition()
                                        .duration(200)
                                        .style("opacity", .9);
                                    tooltip.html(d.id)
                                        .style("left", (d3.event.pageX) + "px")
                                        .style("top", (d3.event.pageY - 28) + "px");
                                })
                                .on("mouseout", function(d) {
                                    tooltip.transition()
                                        .duration(500)
                                        .style("opacity", 0);
                                })  
                                .on("click", function(d) {
                                    var node = cy.nodes().filter(node => node.id() === d.id);
                                    var text = selectedAttributes.map(attr => {
                                    var attrValue = node.data(attr);
                                    if (typeof attrValue === 'string') {
                                        // Replace searched words with highlighted version
                                        searchQueries.forEach(query => {
                                        var regex = new RegExp(query, 'gi');
                                        attrValue = attrValue.replace(regex, '<span style="color: turquoise;">$&</span>');
                                    });
                                    }
                                    return attrValue;
                                }).join(', ');
                                nodeAttributes.innerHTML = text;

                                // Wrap each word in a span element
                                var words = text.split(' ');
                                var wrappedText = words.map(word => `<span class="word">${word}</span>`).join(' ');
                                nodeAttributes.innerHTML = wrappedText;

                                var wordElements = document.querySelectorAll('.word');


                                wordElements.forEach(wordElement => {
                                    wordElement.addEventListener('dblclickk', function(event) {
                                        event.preventDefault();

                                        // Show the custom context menu
                                        var contextMenu = document.getElementById('custom-context-menu');
                                        contextMenu.style.display = 'block';
                                        contextMenu.style.left = `${event.pageX}px`;
                                        contextMenu.style.top = `${event.pageY}px`;

                                        // Set the word as a data attribute of the "Check in dictionary" link
                                        var checkInDictLink = document.getElementById('check-in-dict');
                                        checkInDictLink.setAttribute('data-word', event.target.textContent);

                                        return false;
                                    });
                                });
                                });                        

                                                                
            }

            // Event listener for the Enter key on the input field
            document.getElementById('advancedSearchInput').addEventListener('keypress', function (e) {
                // Check if the Enter key was pressed
                if (e.key === 'Enter') {

                    var inputElement = document.getElementById('advancedSearchInput');
                    var searchText = inputElement.value;
                    advancedSearch(searchText);
                }
            });





                
                 
                 // Assuming you have an input element with the ID 'color-picker-specificnode'
                  const colorPickerSpecificNode = document.getElementById('color-picker-specificnode');

                  // Update node color when the color picker changes
                  colorPickerSpecificNode.addEventListener('input', function() {
                    const selectedNode = cy.$(':selected'); // Get the currently selected node

                    if (selectedNode.length > 0) {
                      const color = colorPickerSpecificNode.value;

                      // Change the background color of the selected node
                      selectedNode.style('background-color', color);
                      
                      
                      // Update the modified color for the selected node
                      modifiedNodeColors.set(selectedNode.id(), color);
                    }
                    
                  });
                  
                  
                  // Update selectedNode whenever a node is selected
                 cy.on('select', 'node', function(event) {
                     selectedNode = event.target;
                     
                     const nodeBackgroundColorRGB = selectedNode.style('background-color');
                     // Convert RGB to hex
                     const nodeBackgroundColorHex = rgbToHex(nodeBackgroundColorRGB);
                     // Update the color picker value
                     colorPickerSpecificNode.value = nodeBackgroundColorHex;
                     
                     selectedNode.addClass('spotted');
                     updateDetailsWindow();
                     const nodeBackgroundColor = selectedNode.style('background-color');
                     


                                    // Get the background color in RGB format
                    
                });
                
                const modifiedNodeColors = new Map();

                // RGB to Hex conversion function
                function rgbToHex(rgb) {
                    const rgbArray = rgb.match(/\d+/g).map(Number);
                    return '#' + rgbArray.map(value => {
                        const hex = value.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');
                }

                 
                 
                 
                 // Clear selectedNode whenever a node is unselected
                 cy.on('unselect', 'node', function() {
                      
                    selectedNode.removeClass('spotted');
                
                    selectedNode = null;
                    updateDetailsWindow();
                     

                 });
                 
                 // Update the details window whenever the selected options change
                 $('#displaySelector').on('change', updateDetailsWindow);
                 
                 function updateDetailsWindow() {
                     if (selectedNode) {
                         // Get the selected attributes
                         const selectedAttributes = $('#displaySelector').select2('data').map(option => option.id);
                         
                         // Build the details content using the selected attributes
                       let detailsContent = '<h2 class="w-full" style="font-weight: bold !important; text-align: center; margin-bottom: 2em;">Sutra ' + selectedNode.id() + '</h2>';               selectedAttributes.forEach(attribute => {
                            if (selectedNode.data(attribute)) {
                                detailsContent += `<p class="w-full "><strong>${attribute}:</strong> ${selectedNode.data(attribute)}</p>`;
                            }
                        });
                        
                         document.getElementById('titleSection').innerHTML = `${selectedNode.data('title') || 'Title'}`;
 
                         // Update the details content
                         document.getElementById('details-content').innerHTML = detailsContent;
                         

                         // Update the editable content
                         document.getElementById('tagsSection').innerHTML = `<strong>Tags:</strong> ${selectedNode.data('tags') || ''}`;
                         document.getElementById('referencesSection').innerHTML = `<strong>References:</strong> ${selectedNode.data('references') || ''}`;
                         document.getElementById('commentsSection').innerHTML = `<strong>Comments:</strong> ${selectedNode.data('comment') || ''}`;
                     } 
                 }

                 function updateDetailsID(nodeId) {
                    // Get the node from the Cytoscape graph
                    var selectedNode = cy.getElementById(nodeId);
                
                    if (selectedNode.length > 0) {
                        // Get the selected attributes
                        const selectedAttributes = $('#displaySelector').select2('data').map(option => option.id);
                
                        // Build the details content using the selected attributes
                        let detailsContent = '<h2>Aphorism Details</h2>';
                        selectedAttributes.forEach(attribute => {
                            if (selectedNode.data(attribute)) {
                                detailsContent += `<p><strong>${attribute}:</strong> ${selectedNode.data(attribute)}</p>`;
                            }
                        });
                        
                        document.getElementById('titleSection').innerHTML = `${selectedNode.data('title') || ''}`;
                
                        // Update the details content
                        document.getElementById('details-content').innerHTML = detailsContent;
                
                        // Update the editable content
                        
                        document.getElementById('tagsSection').innerHTML = `<strong>Tags:</strong> ${selectedNode.data('tags') || ''}`;
                        document.getElementById('referencesSection').innerHTML = `<strong>References:</strong> ${selectedNode.data('references') || ''}`;
                        document.getElementById('commentsSection').innerHTML = `<strong>Comments:</strong> ${selectedNode.data('comment') || ''}`;
                    } else {
                        // Clear the details content if no node is selected
                        
                        
                        document.getElementById('details-content').innerHTML = '';
                        document.getElementById('tagsSection').innerHTML = '<strong>Tags:</strong>';
                        document.getElementById('referencesSection').innerHTML = '<strong>References:</strong>';
                        document.getElementById('commentsSection').innerHTML = '<strong>Comments:</strong>';
                    }
                }
                


                cy.on('tap', 'node', function (event) {
                    const node = event.target;
                    openLeftSidebar(node);
                });   
            })
            .catch(error => console.error('Error:', error));
        });


        document.getElementById('sidebarToggle').addEventListener('click', function() {
            var sidebar = document.getElementById('sidebar');
            if (sidebar.style.transform === "translateX(100%)") {
              sidebar.style.transform = "translateX(0)";  
              sidebar.style.boxShadow = "-1px 0px 3px 0px rgba(0,0,0,0.3)";        
            } else {
              sidebar.style.transform = "translateX(100%)";
            }
          });
          
          function toggleContent() {
            var cy = document.getElementById('cy');
            var textContainer = document.getElementById('textContainer');
            var myDiv = document.getElementById('myDiv');
            
            document.body.style.backgroundColor = "#fdfdfd";
            
            cy.style.display = "block";
            cy.style.opacity = "0";
            myDiv.style.opacity = "0.75";
            
            // After a delay, change the opacity of the background
            setTimeout(function() {
                myDiv.style.opacity = "0.75";
                cy.style.opacity = "0.15";
            }, 500);  // Delay in milliseconds

            // After a delay, change the opacity of the background
            setTimeout(function() {
                myDiv.style.opacity = "0.60";
                cy.style.opacity = "0.30";
            }, 1000);  // Delay in milliseconds
            
            // After a delay, change the opacity of the background
            setTimeout(function() {
                myDiv.style.opacity = "0.50";
                cy.style.opacity = "0.45";
            }, 1500);  // Delay in milliseconds
            // After a delay, change the opacity of the background
            setTimeout(function() {
                myDiv.style.opacity = "0.25";
                cy.style.opacity = "0.65";
                wonderHeader.style.backgroundColor = "#fbfbfb"
            }, 2000);  // Delay in milliseconds
            
            // After a longer delay, remove the background
            setTimeout(function() {       
                myDiv.style.backgroundImage = "none";
                myDiv.style.opacity = "1";
                textContainer.style.display = "none";
                cy.style.opacity = "1";

                var divideLine = document.getElementById('divideLine');
                // Remove the old class
                divideLine.classList.remove('inset-x-1/4');
                divideLine.classList.remove('bg-gray-700');

                // Add the new class
                divideLine.classList.add('inset-x-0');
                divideLine.classList.add('bg-gray-500');


                var rightSidebar = document.getElementById('sidebar');
                rightSidebar.style.transform = "translateX(0)";  
                rightSidebar.style.boxShadow = "-1px 0px 3px 0px rgba(0,0,0,0.3)";       
                

                var leftSidebar = document.getElementById('leftSidebar');
                leftSidebar.style.transform = "translateX(0)";
                leftSidebar.style.boxShadow = "1px 0px 3px 0px rgba(0,0,0,0.3)";
                
            }, 2500);  // Delay in milliseconds
        }

         interact('#leftSidebar')
            .resizable({
                edges: { left: true, right: true, bottom: false, top: false },
                modifiers: [
                interact.modifiers.restrictEdges({
                    outer: 'parent',
                }),
                interact.modifiers.restrictSize({
                    min: { width: 100, height: 50 },
                }),
                ],
                inertia: true,
            })
            .on('resizemove', function (event) {
                var target = event.target;
                var x = parseFloat(target.getAttribute('data-x')) || 0;

                target.style.width = event.rect.width + 'px';
                target.style.height = event.rect.height + 'px';
                x += event.deltaRect.left;
                target.style.transform = 'translate(' + x + 'px)';
                target.setAttribute('data-x', x);
            });

                
          interact('.resizable-section')
            .resizable({
              edges: {  top: true, bottom: true },

              onmove: function (event) {
                var target = event.target;
                
                var height = parseFloat(target.getAttribute('data-height')) || target.offsetHeight;


                height += event.deltaRect.height;


                target.style.height = height + 'px';


                target.setAttribute('data-height', height);
              },
            });


            interact('.modal-content')
                .draggable({
                    listeners: {
                    move(event) {
                        var target = event.target;
                        var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                        var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                        target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';

                        target.setAttribute('data-x', x);
                        target.setAttribute('data-y', y);
                    }
                    },
                    inertia: true,
                    modifiers: [
                    interact.modifiers.restrictRect({
                        restriction: 'parent',
                        endOnly: true
                    })
                    ]
                })
                .resizable({
                    // resize from all edges and corners
                    edges: { left: true, right: true, bottom: true, top: true },

                    listeners: {
                    move(event) {
                        var target = event.target;
                        var x = (parseFloat(target.getAttribute('data-x')) || 0);
                        var y = (parseFloat(target.getAttribute('data-y')) || 0);

                        // update the element's style
                        target.style.width = event.rect.width + 'px';
                        target.style.height = event.rect.height + 'px';

                        // translate when resizing from top or left edges
                        x += event.deltaRect.left;
                        y += event.deltaRect.top;

                        target.style.transform = 'translate(' + x + 'px,' + y + 'px)';

                        target.setAttribute('data-x', x);
                        target.setAttribute('data-y', y);
                    }
                    },
                    modifiers: [
                    // keep the edges inside the parent
                    interact.modifiers.restrictEdges({
                        outer: 'parent'
                    }),

                    // minimum size
                    interact.modifiers.restrictSize({
                        min: { width: 100, height: 50 }
                    })
                    ],

                    inertia: true
                });

                interact('.context_menu')
                .draggable({
                    listeners: {
                    move(event) {
                        var target = event.target;
                        var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                        var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                        target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';

                        target.setAttribute('data-x', x);
                        target.setAttribute('data-y', y);
                    }
                    },
                    inertia: true,
                    modifiers: [
                    interact.modifiers.restrictRect({
                        restriction: 'parent',
                        endOnly: true
                    })
                    ]
                })
                .resizable({
                    // resize from all edges and corners
                    edges: { left: true, right: true, bottom: true, top: true },

                    listeners: {
                    move(event) {
                        var target = event.target;
                        var x = (parseFloat(target.getAttribute('data-x')) || 0);
                        var y = (parseFloat(target.getAttribute('data-y')) || 0);

                        // update the element's style
                        target.style.width = event.rect.width + 'px';
                        target.style.height = event.rect.height + 'px';

                        // translate when resizing from top or left edges
                        x += event.deltaRect.left;
                        y += event.deltaRect.top;

                        target.style.transform = 'translate(' + x + 'px,' + y + 'px)';

                        target.setAttribute('data-x', x);
                        target.setAttribute('data-y', y);
                    }
                    },
                    modifiers: [
                    // keep the edges inside the parent
                    interact.modifiers.restrictEdges({
                        outer: 'parent'
                    }),

                    // minimum size
                    interact.modifiers.restrictSize({
                        min: { width: 100, height: 50 }
                    })
                    ],

                    inertia: true
                });

                // Initialize Editor.js
                var editor = new EditorJS({
                    holder: 'editorjs'
                });



        // Fetch the CSV data
        fetch('stopwords.csv')
            .then(response => response.text())
            .then(text => new TextDecoder("utf-8").decode(new TextEncoder().encode(text)))
            .then(data => {
                // Parse the CSV data
                var parsedData = Papa.parse(data, {header: true}).data;

                // Convert the array of objects to an array of stopwords
                var stopwords = parsedData.map(function(d) { return d.stopword; });

                // Print the stopwords
                //console.log(stopwords);
            })
            .catch(error => console.error('Error:', error));
                                

                        d3.csv("stopwords.csv").then(function(data) {
            // Convert the array of objects to an array of stopwords
            var stopwordsd3 = data.map(function(d) { return d.stopword; });

            // Print the stopwords
            //console.log(stopwordsd3);
        }).catch(function(error){
            console.log("Error:", error);
        });
            
    </script>
</body>
</html> 
